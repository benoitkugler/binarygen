package testpackage

import (
	"encoding/binary"
	"fmt"
)

// Code generated by bin-parser-gen. DO NOT EDIT

func parseVarInstance(src []byte) (VarInstance, int, error) {
	var item VarInstance
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 4 {
			return VarInstance{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
		}

		_ = subSlice[3] // early bound checking
		item.Subfamily = uint16(binary.BigEndian.Uint16(subSlice[0:2]))
		item.PSStringID = uint16(binary.BigEndian.Uint16(subSlice[2:4]))
		n += 4
	}
	return item, n, nil
}

func parseArrayLike(src []byte) (arrayLike, int, error) {
	var item arrayLike
	n := 0
	return item, n, nil
}

func parseComplexeSubtable(src []byte) (complexeSubtable, int, error) {
	var item complexeSubtable
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 6 {
			return complexeSubtable{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
		}

		_ = subSlice[5] // early bound checking
		item.version = uint16(binary.BigEndian.Uint16(subSlice[0:2]))
		item.x = int16(binary.BigEndian.Uint16(subSlice[2:4]))
		item.y = int16(binary.BigEndian.Uint16(subSlice[4:6]))
		n += 6
	}
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 28 {
			return complexeSubtable{}, 0, fmt.Errorf("EOF: expected length: 28, got %d", L)
		}

		_ = subSlice[27] // early bound checking
		item.u.fromUint(binary.BigEndian.Uint16(subSlice[0:2]))
		item.v.fromUint(binary.BigEndian.Uint16(subSlice[2:4]))
		item.a = int64(binary.BigEndian.Uint64(subSlice[4:12]))
		item.b = int64(binary.BigEndian.Uint64(subSlice[12:20]))
		item.c = int64(binary.BigEndian.Uint64(subSlice[20:28]))
		n += 28
	}
	return item, n, nil
}

func parseComposed(src []byte) (composed, int, error) {
	var item composed
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 72 {
			return composed{}, 0, fmt.Errorf("EOF: expected length: 72, got %d", L)
		}

		_ = subSlice[71] // early bound checking
		item.a.mustParse(subSlice[0:])
		item.b.mustParse(subSlice[36:])
		n += 72
	}
	return item, n, nil
}

func parseComposed2(src []byte) (composed2, int, error) {
	var item composed2
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 3 {
			return composed2{}, 0, fmt.Errorf("EOF: expected length: 3, got %d", L)
		}

		_ = subSlice[2] // early bound checking
		item.a = byte(subSlice[0])
		item.b = byte(subSlice[1])
		item.c = byte(subSlice[2])
		n += 3
	}
	return item, n, nil
}

func parseEmbeded(src []byte) (embeded, int, error) {
	var item embeded
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 2 {
			return embeded{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}

		_ = subSlice[1] // early bound checking
		item.a = byte(subSlice[0])
		item.b = byte(subSlice[1])
		n += 2
	}
	return item, n, nil
}

func parseLookup(src []byte) (lookup, int, error) {
	var item lookup
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 36 {
			return lookup{}, 0, fmt.Errorf("EOF: expected length: 36, got %d", L)
		}

		_ = subSlice[35] // early bound checking
		item.a = int32(binary.BigEndian.Uint32(subSlice[0:4]))
		item.b = int32(binary.BigEndian.Uint32(subSlice[4:8]))
		item.c = int32(binary.BigEndian.Uint32(subSlice[8:12]))
		item.d = uint32(binary.BigEndian.Uint32(subSlice[12:16]))
		item.e = int64(binary.BigEndian.Uint64(subSlice[16:24]))
		item.g = byte(subSlice[24])
		item.h = byte(subSlice[25])
		item.t = tag(binary.BigEndian.Uint32(subSlice[26:30]))
		item.v.fromUint(binary.BigEndian.Uint16(subSlice[30:32]))
		item.w = fl32FromUint(binary.BigEndian.Uint32(subSlice[32:36]))
		n += 36
	}
	return item, n, nil
}

func parseSimpleSubtable(src []byte) (simpleSubtable, int, error) {
	var item simpleSubtable
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 6 {
			return simpleSubtable{}, 0, fmt.Errorf("EOF: expected length: 6, got %d", L)
		}

		_ = subSlice[5] // early bound checking
		item.version = uint16(binary.BigEndian.Uint16(subSlice[0:2]))
		item.x = int16(binary.BigEndian.Uint16(subSlice[2:4]))
		item.y = int16(binary.BigEndian.Uint16(subSlice[4:6]))
		n += 6
	}
	return item, n, nil
}

func parseWithOffset(src []byte) (withOffset, int, error) {
	var item withOffset
	n := 0
	{
		subSlice := src[n:]
		if L := len(subSlice); L < 13 {
			return withOffset{}, 0, fmt.Errorf("EOF: expected length: 13, got %d", L)
		}

		_ = subSlice[12] // early bound checking
		item.version = uint16(binary.BigEndian.Uint16(subSlice[0:2]))
		offsetToOffsetToSlice := int(binary.BigEndian.Uint32(subSlice[2:6]))
		offsetToOffsetToStruct := int(binary.BigEndian.Uint32(subSlice[6:10]))
		item.a = byte(subSlice[10])
		item.b = byte(subSlice[11])
		item.c = byte(subSlice[12])
		n += 13
	}
	return item, n, nil
}
