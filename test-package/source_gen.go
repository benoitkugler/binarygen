package testpackage

import (
	"encoding/binary"
	"fmt"
)

// Code generated by binarygen from ../../test-package/source.go. DO NOT EDIT

func ParseWithOffset(src []byte) (WithOffset, int, error) {
	var item WithOffset
	n := 0
	{
		if L := len(src); L < 2 {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}
		_ = src[1] // early bound checking
		item.version = binary.BigEndian.Uint16(src[0:])
		n += 2

	}
	{
		if L := len(src); L < 6 {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
		}
		offset := int(binary.BigEndian.Uint32(src[2:]))
		n += 4
		if L := len(src); L < offset {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", offset, L)
		}

		if L := len(src); L < offset+2 {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[offset:]))
		offset += 2

		if L := len(src); L < offset+arrayLength*8 {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", offset+arrayLength*8, L)
		}

		item.offsetToSlice = make([]uint64, arrayLength) // allocation guarded by the previous check
		for i := range item.offsetToSlice {
			item.offsetToSlice[i] = binary.BigEndian.Uint64(src[offset+i*8:])
		}
		offset += arrayLength * 8
	}
	{
		if L := len(src); L < 10 {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
		}
		offset := int(binary.BigEndian.Uint32(src[6:]))
		n += 4
		if L := len(src); L < offset {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", offset, L)
		}

		var (
			err  error
			read int
		)
		item.offsetToStruct, read, err = parseVarSize(src)
		if err != nil {
			return WithOffset{}, 0, err
		}
		offset += read

	}
	{
		if L := len(src); L < 13 {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: 3, got %d", L)
		}
		_ = src[12] // early bound checking
		item.a = src[10]
		item.b = src[11]
		item.c = src[12]
		n += 3

	}
	{
		if L := len(src); L < 15 {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}
		offset := int(binary.BigEndian.Uint16(src[13:]))
		n += 2
		if L := len(src); L < offset {
			return WithOffset{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", offset, L)
		}

		item.offsetToUnbounded = src[offset:]
		offset = len(src)
	}
	return item, n, nil
}

func ParseWithOpaque(src []byte) (WithOpaque, int, error) {
	var item WithOpaque
	n := 0
	{
		if L := len(src); L < 2 {
			return WithOpaque{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}
		_ = src[1] // early bound checking
		item.f = binary.BigEndian.Uint16(src[0:])
		n += 2

	}
	{

		read, err := item.opaque.customParse(src[2:])
		if err != nil {
			return WithOpaque{}, 0, err
		}
		n += read

	}
	return item, n, nil
}

func ParseWithRawdata(src []byte, defautCount int, startToCount int) (WithRawdata, int, error) {
	var item WithRawdata
	n := 0
	{

		L := int(0 + defautCount)
		if len(src) < L {
			return WithRawdata{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", L, len(src))
		}
		item.defaut = src[0:L]
		n = L

	}
	{

		L := int(0 + startToCount)
		if len(src) < L {
			return WithRawdata{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", L, len(src))
		}
		item.startTo = src[0:L]
		n = L

	}
	{

		item.currentToEnd = src[n:]
		n = len(src)
	}
	{

		item.startToEnd = src[0:]
		n = len(src)
	}
	return item, n, nil
}

func ParseWithSlices(src []byte) (WithSlices, int, error) {
	var item WithSlices
	n := 0
	{
		if L := len(src); L < 2 {
			return WithSlices{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}
		_ = src[1] // early bound checking
		item.length = binary.BigEndian.Uint16(src[0:])
		n += 2

	}
	{
		arrayLength := int(item.length)

		offset := 2
		for i := 0; i < arrayLength; i++ {
			elem, read, err := parseVarSize(src[offset:])
			if err != nil {
				return WithSlices{}, 0, err
			}
			item.s1 = append(item.s1, elem)
			offset += read
		}
		n = offset
	}
	return item, n, nil
}

func parseVarSize(src []byte) (varSize, int, error) {
	var item varSize
	n := 0
	{
		if L := len(src); L < 4 {
			return varSize{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
		}
		_ = src[3] // early bound checking
		item.f1 = binary.BigEndian.Uint32(src[0:])
		n += 4

	}
	{
		if L := len(src); L < 6 {
			return varSize{}, 0, fmt.Errorf("EOF: expected length: 2, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint16(src[4:]))
		n += 2

		if L := len(src); L < 6+arrayLength*4 {
			return varSize{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", 6+arrayLength*4, L)
		}

		item.array = make([]uint32, arrayLength) // allocation guarded by the previous check
		for i := range item.array {
			item.array[i] = binary.BigEndian.Uint32(src[6+i*4:])
		}
		n += arrayLength * 4
	}
	{
		if L := len(src); L < n+4 {
			return varSize{}, 0, fmt.Errorf("EOF: expected length: 4, got %d", L)
		}
		arrayLength := int(binary.BigEndian.Uint32(src[n:]))
		n += 4

		if L := len(src); L < n+arrayLength*4 {
			return varSize{}, 0, fmt.Errorf("EOF: expected length: %d, got %d", n+arrayLength*4, L)
		}

		item.stucts = make([]withAlias, arrayLength) // allocation guarded by the previous check
		for i := range item.stucts {
			item.stucts[i].mustParse(src[n+i*4:])
		}
		n += arrayLength * 4
	}
	return item, n, nil
}

func (item *singleScope) mustParse(src []byte) {
	_ = src[52] // early bound checking
	item.a = int32(binary.BigEndian.Uint32(src[0:]))
	item.b = int32(binary.BigEndian.Uint32(src[4:]))
	item.c = int32(binary.BigEndian.Uint32(src[8:]))
	item.d = binary.BigEndian.Uint32(src[12:])
	item.e = int64(binary.BigEndian.Uint64(src[16:]))
	item.g = src[24]
	item.h = src[25]
	item.t = tag(binary.BigEndian.Uint32(src[26:]))
	item.v = float214(binary.BigEndian.Uint32(src[30:]))
	item.w = fl32FromUint(binary.BigEndian.Uint32(src[34:]))
	item.array1[0] = src[39]
	item.array1[1] = src[40]
	item.array1[2] = src[41]
	item.array1[3] = src[42]
	item.array1[4] = src[43]
	item.array2[0] = binary.BigEndian.Uint16(src[45:])
	item.array2[1] = binary.BigEndian.Uint16(src[47:])
	item.array2[2] = binary.BigEndian.Uint16(src[49:])
	item.array2[3] = binary.BigEndian.Uint16(src[51:])
	item.array2[4] = binary.BigEndian.Uint16(src[53:])
}

func (item *subtableITF1) mustParse(src []byte) {
	_ = src[7] // early bound checking
	item.F = binary.BigEndian.Uint64(src[0:])
}

func (item *subtableITF2) mustParse(src []byte) {
	_ = src[0] // early bound checking
	item.F = src[0]
}

func (item *withAlias) mustParse(src []byte) {
	_ = src[3] // early bound checking
	item.f = fl32FromUint(binary.BigEndian.Uint32(src[0:]))
}
