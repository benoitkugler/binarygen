// Package binarygen implements a binary parser and writer generator.
package binarygen

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
)

func Generate(path string) error {
	an, err := importSource(path)
	if err != nil {
		return err
	}

	code := an.generateCode()

	outfile := filepath.Join(filepath.Dir(path), "binary.go")
	content := fmt.Sprintf(`
	package %s

	// Code generated by bin-parser-gen. DO NOT EDIT

	%s
	`, an.pkgName, code)

	err = os.WriteFile(outfile, []byte(content), os.ModePerm)
	if err != nil {
		return err
	}

	err = exec.Command("goimports", "-w", outfile).Run()

	return err
}

func (an *analyser) generateCode() string {
	code := ""

	var keys []string
	for k := range an.structs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		code += an.generateCodeForStruct(an.structs[k]) + "\n"
	}

	return code
}

func (an *analyser) generateCodeForStruct(str structDef) string {
	chunks := an.analyseStruct(str)

	// important special case : all fields have fixed size
	if len(chunks) == 1 {
		if fs, ok := chunks[0].(fixedSizeFields); ok {
			// add a mustParse version and use it in parse
			parserCode := fs.generateMustParser("data")
			finalCode := fmt.Sprintf(`func (out *%s) mustParse(data []byte) {
			%s}
			
			`, str.name, parserCode)
			finalCode += fs.generateParserUnique(str.name)

			body := fs.generateWriter("data", "item")
			finalCode += fmt.Sprintf(`func (item %s) writeTo(data []byte) {
				%s}
				
			`, str.name, body)
			finalCode += fs.generateAppenderUnique(str.name)

			return finalCode
		}
	}

	// general case
	finalCode := generateParserForStruct(chunks, str.name)
	finalCode += generateAppenderForStruct(chunks, str.name)
	return finalCode
}
