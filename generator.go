// Package binarygen implements a binary parser and writer generator,
// understanding Opentype tables binary format.
package binarygen

import (
	"fmt"
	"os"
	"os/exec"
	"sort"
	"strings"
	"unicode"
)

func Generate(path string) error {
	an, err := importSource(path)
	if err != nil {
		return err
	}

	an.performAnalysis()

	code := an.generateCode()

	outfile := strings.TrimSuffix(path, ".go") + "_gen.go"
	content := []byte(fmt.Sprintf(`
	package %s

	// Code generated by binarygen from %s. DO NOT EDIT

	%s
	`, an.pkgName, path, code))

	err = os.WriteFile(outfile, content, os.ModePerm)
	if err != nil {
		return err
	}

	err = exec.Command("goimports", "-w", outfile).Run()

	return err
}

func (an *analyser) generateCode() string {
	var keys []string
	for k := range an.structLayouts {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	code := ""
	for _, k := range keys {
		st := an.structLayouts[k]
		code += st.generateParser() + "\n"
	}

	return code
}

// ----------------------------- V2 -----------------------------
type codeContext struct {
	// <variableName> = parse<typeName>(<byteSliceName>)
	// <byteSliceName> = appendTo(<variableName>, <byteSliceName>)
	typeName      string // the name of the type being generated
	objectName    string // the go struct being parsed or dumped
	byteSliceName string // the name of the []byte being read or written
	offsetExpr    string // the name of the variable holding the current offset or a number
}

func (cc codeContext) returnError(errVariable string) string {
	return fmt.Sprintf("return %s{}, 0, %s", cc.typeName, errVariable)
}

// return <object>.<field>
func (cc codeContext) variableExpr(field string) string {
	return fmt.Sprintf("%s.%s", cc.objectName, field)
}

// set `offsetExpr` to <offset> + i * <elementSize>
func (cc *codeContext) setArrayLikeOffsetExpr(elementSize int, offsetExpr string) {
	if elementSize == 1 {
		if offsetExpr == "0" {
			cc.offsetExpr = "i"
		} else {
			cc.offsetExpr = fmt.Sprintf("%s + i", offsetExpr)
		}
	} else {
		if offsetExpr == "0" {
			cc.offsetExpr = fmt.Sprintf("i * %d", elementSize)
		} else {
			cc.offsetExpr = fmt.Sprintf("%s + i * %d", offsetExpr, elementSize)
		}
	}
}

func (cc codeContext) parseFunction(args, body []string) string {
	isExported := unicode.IsUpper([]rune(cc.typeName)[0])
	funcTitle := "parse"
	if isExported {
		funcTitle = "Parse"
	}
	return fmt.Sprintf(`func %s%s(%s) (%s, int, error) {
		var %s %s
		%s
		return %s, n, nil
	}
	`, funcTitle, strings.Title(cc.typeName), strings.Join(args, ","), cc.typeName, cc.objectName,
		cc.typeName, strings.Join(body, "\n"), cc.objectName)
}

// one or many field whose parsing (or writting)
// is grouped to reduce length checks and allocations
type group interface {
	// returns the code blocks
	// no trailing new line is required
	parser(cc codeContext) string

	// returns the code blocks
	// no trailing new line is required
	appender(cc codeContext) string
}

// group definition

func (st structLayout) generateParser() string {
	context := codeContext{
		typeName:      st.name_,
		objectName:    "item",
		byteSliceName: "src",
		offsetExpr:    "n",
	}

	body, args := []string{"n := 0"}, []string{fmt.Sprintf("%s []byte", context.byteSliceName)}

	groups := st.groups()
	if len(groups) == 0 {
		// empty struct are useful : generate the trivial parser
		return context.parseFunction([]string{"[]byte"}, []string{"n := 0"})
	}

	for _, arg := range st.requiredArgs() {
		args = append(args, arg.asSignature())
	}

	// important special case : all fields have fixed size
	// with no offset
	_, isStaticSize := st.staticSize()
	if fs, isFixedSize := groups[0].(fixedSizeList); len(groups) == 1 && isFixedSize && isStaticSize {
		mustParse, parseBody := fs.mustParserFunction(context)
		body = append(body, parseBody...)

		finalCode := mustParse + "\n\n" + context.parseFunction(args, body)

		return finalCode
	}

	for _, group := range groups {
		body = append(body, group.parser(context))
	}

	finalCode := context.parseFunction(args, body)

	return finalCode
}
