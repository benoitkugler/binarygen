// Package binarygen implements a binary parser and writer generator.
package binarygen

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
)

func Generate(path string) error {
	an, err := importSource(path)
	if err != nil {
		return err
	}

	// code := an.generateCode()
	code := an.generateCode2()

	outfile := filepath.Join(filepath.Dir(path), "binary.go")
	content := []byte(fmt.Sprintf(`
	package %s

	// Code generated by bin-parser-gen. DO NOT EDIT

	%s
	`, an.pkgName, code))

	err = os.WriteFile(outfile, content, os.ModePerm)
	if err != nil {
		return err
	}

	err = exec.Command("goimports", "-w", outfile).Run()

	return err
}

func (an *analyser) generateCode() string {
	code := ""

	var keys []string
	for k := range an.structDefs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		code += an.generateCodeForStruct(an.structDefs[k]) + "\n"
	}

	return code
}

func (an *analyser) generateCode2() string {
	var keys []string
	for k := range an.structDefs {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	code := ""
	for _, k := range keys {
		v := an.structDefs[k]
		st := an.analyzeStruct(v)
		code += st.generateParser() + "\n"
	}

	return code
}

func (an *analyser) generateCodeForStruct(str structDef) string {
	chunks := an.analyseStruct(str)

	// important special case : all fields have fixed size
	if len(chunks) == 1 {
		if fs, ok := chunks[0].(fixedSizeFields); ok {
			// add a mustParse version and use it in parse
			parserCode := fs.generateMustParser("data")
			finalCode := fmt.Sprintf(`func (out *%s) mustParse(data []byte) {
			%s}
			
			`, str.name, parserCode)
			finalCode += fs.generateParserUnique(str.name)

			// write

			body := fs.generateWriter("data", "item")
			finalCode += fmt.Sprintf(`func (item %s) writeTo(data []byte) {
				%s}
				
			`, str.name, body)
			finalCode += fs.generateAppenderUnique(str.name)

			return finalCode
		}
	}

	// general case
	finalCode := generateParserForStruct(chunks, str.name)
	finalCode += generateAppenderForStruct(chunks, str.name)
	return finalCode
}

// ----------------------------- V2 -----------------------------
type codeContext struct {
	// <variableName> = parse<typeName>(<byteSliceName>)
	// <byteSliceName> = appendTo(<variableName>, <byteSliceName>)
	typeName      string // the name of the type being generated
	objectName    string // the go struct being parsed or dumped
	byteSliceName string // the name of the []byte being read or written
	offsetName    string // the name of the variable holding the current offset
}

func (cc codeContext) returnError(errVariable string) string {
	return fmt.Sprintf("return %s{}, 0, %s", cc.typeName, errVariable)
}

// return <object>.<field>
func (cc codeContext) variableExpr(field string) string {
	return fmt.Sprintf("%s.%s", cc.objectName, field)
}

// one or many field whose parsing (or writting)
// is grouped to reduce length checks and allocations
type group interface {
	// return an (optional) slice of arguments to add to the parse and appendTo functions
	requiredArgs() []string

	// returns the code blocks
	// no trailing new line is required
	parser(cc codeContext) []string

	// returns the code blocks
	// no trailing new line is required
	appender(cc codeContext) []string
}

// group definition

// TODO:

func (fixedSizeList) requiredArgs() []string { return nil }

func (fixedSizeList) appender(cc codeContext) []string { return nil }

type standaloneField structField

func (standaloneField) requiredArgs() []string { return nil }

func (standaloneField) parser(cc codeContext) []string { return nil }

func (standaloneField) appender(cc codeContext) []string { return nil }

func (st structLayout) generateParser() string {
	groups := st.groups()

	context := codeContext{
		typeName:      st.name,
		objectName:    "item",
		byteSliceName: "src",
		offsetName:    "n",
	}
	chunks, args := []string{"n := 0"}, []string{fmt.Sprintf("%s []byte", context.byteSliceName)}

	for _, group := range groups {
		chunks = append(chunks, group.parser(context)...)
		args = append(args, group.requiredArgs()...)
	}

	finalCode := fmt.Sprintf(`func parse%s(%s) (%s, int, error) {
		var %s %s
		%s
		return %s, n, nil
	}
	
	`, strings.Title(st.name), strings.Join(args, ","), st.name, context.objectName,
		st.name, strings.Join(chunks, "\n"), context.objectName)

	return finalCode
}
