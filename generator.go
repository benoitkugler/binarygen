// Package binarygen implements a binary parser and writer generator,
// understanding Opentype tables binary format.
package binarygen

import (
	"errors"
	"fmt"
	"go/types"
	"io/fs"
	"os"
	"os/exec"
	"sort"
	"strings"
	"unicode"
)

func Generate(path string) error {
	outfile := strings.TrimSuffix(path, ".go") + "_gen.go"

	// start by cleaning up existing file
	err := os.Remove(outfile)
	if err != nil && !errors.Is(err, fs.ErrNotExist) {
		return err
	}

	an, err := importSource(path)
	if err != nil {
		return err
	}

	an.performAnalysis()

	code := an.generateCode()

	content := []byte(fmt.Sprintf(`
	package %s

	// Code generated by binarygen from %s. DO NOT EDIT

	%s
	`, an.pkgName, path, code))

	err = os.WriteFile(outfile, content, os.ModePerm)
	if err != nil {
		return err
	}

	err = exec.Command("goimports", "-w", outfile).Run()

	return err
}

// check if the function has already been generated
func (an *analyser) isFuncOrMethodDefined(id string) bool {
	if typeName, method, isMethod := strings.Cut(id, "."); isMethod {
		ty := an.scope.Lookup(typeName).Type().(*types.Named)
		for i := 0; i < ty.NumMethods(); i++ {
			if ty.Method(i).Name() == method {
				return true
			}
		}
		return false
	}
	return an.scope.Lookup(id) != nil
}

func (an *analyser) generateCode() string {
	var keys []string
	for k := range an.structLayouts {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	buffer := newDeclarationBuffer()
	for _, k := range keys {
		st := an.structLayouts[k]
		for _, decl := range st.generateParser() {
			if an.isFuncOrMethodDefined(decl.id) {
				continue
			}
			buffer.add(decl)
		}
	}

	return buffer.code()
}

type declarationBuffer struct {
	decls []declaration
	seen  map[string]bool
}

func newDeclarationBuffer() declarationBuffer {
	return declarationBuffer{seen: map[string]bool{}}
}

func (db *declarationBuffer) add(decl declaration) {
	if db.seen[decl.id] {
		return
	}
	db.decls = append(db.decls, decl)
	db.seen[decl.id] = true
}

func (db declarationBuffer) code() string {
	var builder strings.Builder
	for _, decl := range db.decls {
		builder.WriteString(decl.content)
	}
	return builder.String()
}

// declaration is a chunk of generated go code,
// with an id used to avoid duplication
type declaration struct {
	id      string
	content string
}

type codeContext struct {
	// <variableName> = parse<typeName>(<byteSliceName>)
	// <byteSliceName> = appendTo(<variableName>, <byteSliceName>)
	typeName      string // the name of the type being generated
	objectName    string // the go struct being parsed or dumped
	byteSliceName string // the name of the []byte being read or written
	offsetExpr    string // the name of the variable holding the current offset or a number
}

func (cc codeContext) returnError(errVariable string) string {
	return fmt.Sprintf("return %s{}, 0, %s", cc.typeName, errVariable)
}

// return <object>.<field>
func (cc codeContext) variableExpr(field string) string {
	return fmt.Sprintf("%s.%s", cc.objectName, field)
}

// set `offsetExpr` to <offset> + i * <elementSize>
func (cc *codeContext) setArrayLikeOffsetExpr(elementSize int, offsetExpr string) {
	if elementSize == 1 {
		if offsetExpr == "0" {
			cc.offsetExpr = "i"
		} else {
			cc.offsetExpr = fmt.Sprintf("%s + i", offsetExpr)
		}
	} else {
		if offsetExpr == "0" {
			cc.offsetExpr = fmt.Sprintf("i * %d", elementSize)
		} else {
			cc.offsetExpr = fmt.Sprintf("%s + i * %d", offsetExpr, elementSize)
		}
	}
}

func (cc codeContext) generateParseFunction(args, body []string) declaration {
	isExported := unicode.IsUpper([]rune(cc.typeName)[0])
	funcTitle := "parse"
	if isExported {
		funcTitle = "Parse"
	}
	funcName := funcTitle + strings.Title(cc.typeName)
	content := fmt.Sprintf(`func %s(%s) (%s, int, error) {
		var %s %s
		%s
		return %s, n, nil
	}
	`, funcName, strings.Join(args, ","), cc.typeName, cc.objectName,
		cc.typeName, strings.Join(body, "\n"), cc.objectName)
	return declaration{id: funcName, content: content}
}

// one or many field whose parsing (or writting)
// is grouped to reduce length checks and allocations
type group interface {
	// returns the code blocks
	// no trailing new line is required
	parser(cc codeContext) string

	// returns the code blocks
	// no trailing new line is required
	appender(cc codeContext) string
}

// group definition

func (st structLayout) generateParser() []declaration {
	context := codeContext{
		typeName:      st.name_,
		objectName:    "item",
		byteSliceName: "src",
		offsetExpr:    "n",
	}

	body, args := []string{"n := 0"}, []string{fmt.Sprintf("%s []byte", context.byteSliceName)}

	groups := st.groups()
	if len(groups) == 0 {
		// empty struct are useful : generate the trivial parser
		return []declaration{context.generateParseFunction([]string{"[]byte"}, []string{"n := 0"})}
	}

	for _, arg := range st.requiredArgs() {
		args = append(args, arg.asSignature())
	}

	// important special case : all fields have fixed size
	// with no offset
	_, isStaticSize := st.staticSize()
	if fs, isFixedSize := groups[0].(fixedSizeList); len(groups) == 1 && isFixedSize && isStaticSize {
		mustParse, parseBody := fs.mustParserFunction(context)
		body = append(body, parseBody...)

		return []declaration{mustParse, context.generateParseFunction(args, body)}
	}

	for _, group := range groups {
		body = append(body, group.parser(context))
	}

	finalCode := context.generateParseFunction(args, body)

	return []declaration{finalCode}
}
